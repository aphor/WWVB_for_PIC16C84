Archived from http://webpages.charter.net/ekyle/WWVB.html 2017-02-07

# Emmett's WWVB Radio Clock

## Overview

This is a project I started around 1981. It is a prime example of what happens when a person keeps changing the design of something -- It never gets built! I all but abandoned it until around 1999, when I decided to try doing at least the decoder portion using a PIC 16C84 chip. I was doing a previous version using an 8085 microprocessor. I really didn't have any development tools, so programming literally in machine language made me run away screaming. Before that, I was using CMOS gates and counters. Talk about a pain to modify! But after working with PIC chips, I can't imagine why anyone would ever use anything but them considering how flexible they are. The main purpose of this project when I started it way back when, was to have a clock that would never need to be set. It would always have and keep the correct time. A company I worked for in the early 80's made a prototype clock in the late 70's, but never marketed it. Today, with the Internet and xntp programs, getting the correct time is not really a problem anymore, so in some ways this project is obsolete. (Not to mention you can buy one of these clocks at Wal Mart for about $20 now days!).

## Operation

All the "Atomic Clocks" you buy in the store and this one as well receive a radio signal from station  [WWVB](http://www.boulder.nist.gov/timefreq/stations/wwvb.htm), which is located in Ft. Collins Colorado.  It is affiliated with the [NIST](http://www.bldrdoc.gov/timefreq/index.html) in Boulder Colorado. Most are familiar with the short wave stations WWV and WWVH (In Hawaii) that broadcast time info on 2.5,5,10,15,20 MHz. Radio station WWVB transmits on a VLF frequency of 60kHz. One of the main reasons for using such a low frequency, is that it provides good coverage throughout the U.S. and it is not as prone to ionospheric affects like the WWV stations are. This makes it possible, with careful measurements, to be able to use the carrier as a frequency standard with accuracy approaching 1x10 ^ -11, or one part in 100 billion/day. The [Time Code](http://tf.nist.gov/stations/wwvbtimecode.htm) is amplitude modulated, where a "High" is full power, and for a "Low" , the output is decreased by 10db. A high to low transition denotes the beginning of a second. There are three characters that are sent. A "0" is represented by a pulse that is low for 200mS. A "1" is low for 500mS, and a Mark is low for 800mS. Marks occur every ten seconds at every N+10. A new minute is represented by two Mark pulses. One at 59-00 and the other from 00-01 seconds. The minutes data sent is the previous minute.

Aside from a PIC decoder and clock, this project requires a receiving antenna, and a receiver. I played with several antenna designs, including ferrite loop sticks. I found the best antenna was a shielded loop antenna. My current antenna is a 2' diameter loop antenna with a built in Cascode J-FET preamplifier, that provides about 6db of gain into 50 Ohms.  The Octagonal loop is made out of 1/2" Copper pipe with elbow fittings. The preamp is housed in an outdoor electrical box which is at the base of the antenna. There are 18 turns of 22ga. wire through the pipe. The pipe Has a 2" gap at the top. I built a similar antenna when I was in the Navy, stationed at Whidbey Island Naval Air Station. It received a 390kHz homer beacon. I went through many receiver designs. Some were pretty elaborate with built in noise blankers, crystal filters, etc. I was going to do a design with double conversion superhet to maintain coherency with the 60kHz carrier, by  first up converting to 455 kHz, amplifying, and then down converting back to 60kHz, using a 395kHz L.O. but, found it was unnecessary. (My intent was to use the carrier as a standard for calibrating things). The signal strength was strong enough that a minimum receiver sensitivity of 5uV was plenty. The final receiver has a sensitivity of about 6uV and a dynamic range of about 70db. Selectivity is pretty broad. (2-3 kHz). The antenna has a Q of about 30, and the receiver only uses two tuned circuits. The main reason was to minimize the ringing effect caused by large noise spikes exciting a narrow band filter. Narrow band filters, crystal or otherwise would be useless unless there was a noise blanker. The decoded data detector is a synchronus detector. The MC1349 and MC1330 video amp - dector pair (Used in many eairly CATV descramblers) work very well for this application.

Oh, yea. This is supposed to be about a PIC project. Well, I saved the best for last. I originally started out using a computer parallel port as the interface to the receiver data output. I wrote a C-program that decoded the time signal. Once I figured out a few things, I got brave enough to try it with a PIC. My original intent for the PIC was to just use it to decode the time signal, so thats what I started out with, once I could do "hello world!" on a PIC. i.e. effectively program it and make LEDs blink. The decoder scheme I came up with samples the receiver output eight times during a 900mS interval and loads it into a register set up as a shift register. A pattern matching algorithm then matches the received sample to one of the three valid codes. i.e. 1,0,Flag. Its essentially does an exclusive OR operation on the sampled data and then and a population counting scheme compares the result with the possible codes. If no codes are matched, or the sampled data could equally match two codes, then the decoder produces an error. It works pretty well. Unfortunately, there are no parity bits in the time code. It is really a primitive code by today's standards. The only way you can really know if your decoded data is valid is to compare it to another minute's worth of data. I believe the main reason for this slow, primitive format was that it was human readable. Someone could decode the time by using a strip chart recoder. Once I had this working, I could drive a 0,1,Flag LED and see the codes in action. Then I started adding more to it, piece by piece and eventually came up with the clock and the decoder, driving an LCD display. Some of it is in C, and some of it is in assembly. There were several things the compiler mangled, so I had to go in and optimize certain portions. I would also like to thank S.G. Hageman for the concept of the "main" function. I know of at least one bug, and I'm sure there are more. Someday I may revisit it and make a better implementation. However its been working for about six years... 

[Emmett Kyle](http://webpages.charter.net/ekyle/index.html)
